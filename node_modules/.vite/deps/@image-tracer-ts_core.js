import "./chunk-PR4QN5HX.js";

// node_modules/@image-tracer-ts/core/dist/index.mjs
var RgbColorData;
(function(RgbColorData2) {
  function toString(c) {
    return `RgbColor(${c.r},${c.g},${c.b})`;
  }
  RgbColorData2.toString = toString;
})(RgbColorData || (RgbColorData = {}));
var RgbColor = class _RgbColor {
  r;
  g;
  b;
  a;
  /**
   * If the `a` value is below this value, a color is considered invisible.
   */
  static MINIMUM_A = 13;
  // that is 0.05
  constructor(r = 0, g = 0, b = 0, a = 255) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  static fromRgbColorData(c) {
    return new _RgbColor(c.r, c.g, c.b, c.a ?? 255);
  }
  static createRandomColor() {
    const color = new _RgbColor();
    color.randomize();
    return color;
  }
  static fromPixelArray(pixelData, pixelIndex, isRgba = true) {
    const color = new _RgbColor();
    color.setFromPixelArray(pixelData, pixelIndex, isRgba);
    return color;
  }
  static fromHex(hex) {
    const values = hex.substring(1).match(/.{1,2}/g)?.map((n) => parseInt(n, 16));
    return _RgbColor.fromPixelArray(values, 0, values.length > 3);
  }
  static buildColorAverage(counter) {
    const r = Math.floor(counter.r / counter.n);
    const g = Math.floor(counter.g / counter.n);
    const b = Math.floor(counter.b / counter.n);
    const a = Math.floor(counter.a / counter.n);
    return new _RgbColor(r, g, b, a);
  }
  isInvisible() {
    return this.a < _RgbColor.MINIMUM_A;
  }
  hasOpacity() {
    return this.a < 255;
  }
  setFromColorCounts(counter) {
    this.r = Math.floor(counter.r / counter.n);
    this.g = Math.floor(counter.g / counter.n);
    this.b = Math.floor(counter.b / counter.n);
    this.a = Math.floor(counter.a / counter.n);
  }
  randomize() {
    this.r = Math.floor(Math.random() * 256);
    this.g = Math.floor(Math.random() * 256);
    this.b = Math.floor(Math.random() * 256);
    this.a = Math.floor(Math.random() * 128) + 128;
  }
  setFromPixelArray(pixelData, pixelIndex, isRgba = true) {
    const pixelWidth = isRgba ? 4 : 3;
    const offset = pixelIndex * pixelWidth;
    this.r = pixelData[offset + 0];
    this.g = pixelData[offset + 1];
    this.b = pixelData[offset + 2];
    this.a = isRgba ? pixelData[offset + 3] : 255;
  }
  get [Symbol.toStringTag]() {
    return `RgbaColor(${this.r},${this.g},${this.b},${this.a})`;
  }
  calculateDistanceToPixelInArray(pixelData, pixelIndex, isRgba = true) {
    const a = isRgba ? pixelData[pixelIndex + 3] : 255;
    return Math.abs(this.r - pixelData[pixelIndex]) + Math.abs(this.g - pixelData[pixelIndex + 1]) + Math.abs(this.b - pixelData[pixelIndex + 2]) + Math.abs(this.a - a);
  }
  equals(color) {
    return this.r === color.r && this.g === color.g && this.b === color.b && this.a === (color.a ?? 255);
  }
  toCssColor() {
    return !this.hasOpacity() ? `rgb(${this.r},${this.g},${this.b})` : `rgba(${this.r},${this.g},${this.b},${this.a})`;
  }
  toCssColorHex() {
    const int = this.toInt32();
    let hex = int.toString(16);
    const leadingZeros = (this.hasOpacity() ? 8 : 6) - hex.length;
    if (leadingZeros > 0) {
      hex = "0".repeat(leadingZeros) + hex;
    }
    return "#" + hex.toUpperCase();
  }
  toInt32() {
    if (!this.hasOpacity()) {
      return (this.r << 16 | this.g << 8 | this.b) >>> 0;
    }
    return (this.r << 24 | this.g << 16 | this.b << 8 | this.a) >>> 0;
  }
};
var ColorDistanceBuffering;
(function(ColorDistanceBuffering2) {
  ColorDistanceBuffering2["OFF"] = "off";
  ColorDistanceBuffering2["ON"] = "on";
  ColorDistanceBuffering2["REASONABLE"] = "reasonable";
})(ColorDistanceBuffering || (ColorDistanceBuffering = {}));
var ColorIndex = class {
  rows;
  // palette color index for each pixel in the image
  palette;
  options;
  verbose;
  constructor(imageData, options, quantizeFunction) {
    this.options = options;
    this.verbose = options.verbose ?? false;
    this.palette = this.buildPalette(imageData, quantizeFunction);
    this.verbose && console.time(" - Color Quantization");
    this.rows = this.buildColorData(imageData, this.palette);
    this.verbose && console.timeEnd(" - Color Quantization");
  }
  /**
   * @param imageData
   * @returns
   */
  buildPalette(imageData, quantizeFunction) {
    const numberOfColors = Math.max(this.options.numberOfColors, 2);
    const palette = quantizeFunction(imageData, numberOfColors);
    if (this.options.verbose) {
      console.log(`Created palette with ${palette.length} colors.`);
    }
    return palette.map((c) => c instanceof RgbColor ? c : RgbColor.fromRgbColorData(c));
  }
  /**
   * Using a form of k-means clustering repeated options.colorClusteringCycles times. http://en.wikipedia.org/wiki/Color_quantization
   *
   *
   * @param imageData
   * @returns
   */
  buildColorData(imageData, palette) {
    let imageColorIndex;
    const numberOfCycles = Math.max(this.options.colorClusteringCycles, 1);
    for (let cycle = 1; cycle <= numberOfCycles; cycle++) {
      const isLastCycle = cycle === numberOfCycles;
      const nextImageColorIndex = this.runClusteringCycle(imageData, palette, isLastCycle);
      const isFinished = isLastCycle || imageColorIndex && this.colorIndexesEqual(imageColorIndex, nextImageColorIndex);
      imageColorIndex = nextImageColorIndex;
      if (isFinished) {
        this.options.verbose && console.log(`Ran ${cycle} clustering cycles`);
        break;
      }
    }
    return imageColorIndex;
  }
  runClusteringCycle(imageData, palette, isLastCycle) {
    const colorIndex = this.buildImageColorIndex(imageData, palette);
    const colorCounts = this.buildColorCounts(imageData, colorIndex, palette.length);
    const numPixels = imageData.width * imageData.height;
    this.adjustPaletteToColorAverages(palette, colorCounts, numPixels, isLastCycle);
    return colorIndex;
  }
  colorIndexesEqual(i1, i2) {
    if (i1.length !== i2.length) {
      return false;
    }
    for (let rowIx = 0; rowIx < i1.length; rowIx++) {
      const row1 = i1[rowIx];
      const row2 = i2[rowIx];
      if (row1.length !== row2.length) {
        return false;
      }
      for (let colIx = 0; colIx < row1.length; colIx++) {
        if (row1[colIx] !== row2[colIx]) {
          return false;
        }
      }
    }
    return true;
  }
  adjustPaletteToColorAverages(palette, colorCounters, numPixels, isLastCycle) {
    for (let k = 0; k < palette.length; k++) {
      const counter = colorCounters[k];
      const colorBelowThreshold = this.options.minColorQuota > 0 && counter.n / numPixels < this.options.minColorQuota;
      if (colorBelowThreshold && !isLastCycle) {
        palette[k].randomize();
      } else if (counter.n > 0) {
        palette[k].setFromColorCounts(counter);
      }
    }
  }
  /**
   * Maps each pixel in the image to the palette index of the closest color.
   *
   * @param imageData
   * @param palette
   * @returns
   */
  buildImageColorIndex(imageData, palette) {
    const bufferingMode = this.options.colorDistanceBuffering;
    const useBuffer = bufferingMode === ColorDistanceBuffering.ON || bufferingMode === ColorDistanceBuffering.REASONABLE && palette.length >= 32;
    return useBuffer ? this.buildImageColorIndexBuffered(imageData, palette) : this.buildImageColorIndexUnbuffered(imageData, palette);
  }
  buildImageColorIndexUnbuffered(imageData, palette) {
    const imageColorIndex = this.initColorIndexArray(imageData.width, imageData.height);
    for (let h = 0; h < imageData.height; h++) {
      for (let w = 0; w < imageData.width; w++) {
        const pixelOffset = (h * imageData.width + w) * 4;
        const closestColorIx = this.findClosestPaletteColorIx(imageData, pixelOffset, palette);
        imageColorIndex[h + 1][w + 1] = closestColorIx;
      }
    }
    return imageColorIndex;
  }
  buildImageColorIndexBuffered(imageData, palette) {
    const imageColorIndex = this.initColorIndexArray(imageData.width, imageData.height);
    const closestColorMap = [];
    let skips = 0, distinctValues = 0;
    for (let h = 0; h < imageData.height; h++) {
      for (let w = 0; w < imageData.width; w++) {
        const pixelOffset = (h * imageData.width + w) * 4;
        const colorId = this.getPixelColorId(imageData, pixelOffset);
        if (closestColorMap[colorId] !== void 0) {
          skips++;
        } else {
          closestColorMap[colorId] = this.findClosestPaletteColorIx(imageData, pixelOffset, palette);
          distinctValues++;
        }
        imageColorIndex[h + 1][w + 1] = closestColorMap[colorId];
      }
    }
    this.verbose && console.log(`Buffered ${distinctValues} colors to skip ${skips} comparisons (`, Math.round(100 * skips / (skips + distinctValues)), "%)");
    return imageColorIndex;
  }
  getPixelColorId(imageData, pixelOffset) {
    return (imageData.data[pixelOffset] << 24 | imageData.data[pixelOffset + 1] << 16 | imageData.data[pixelOffset + 2] << 8 | imageData.data[pixelOffset + 3]) >>> 0;
  }
  initColorIndexArray(imgWidth, imgHeight) {
    const imageColorIndex = [];
    for (let h = 0; h < imgHeight + 2; h++) {
      imageColorIndex[h] = new Array(imgWidth + 2).fill(-1);
    }
    return imageColorIndex;
  }
  buildColorCounts(imageData, imageColorIndex, numberOfColors) {
    const colorCounts = this.initColorCounts(numberOfColors);
    for (let h = 0; h < imageData.height; h++) {
      for (let w = 0; w < imageData.width; w++) {
        const closestColorIx = imageColorIndex[h + 1][w + 1];
        const colorCounter = colorCounts[closestColorIx];
        const pixelOffset = (h * imageData.width + w) * 4;
        colorCounter.r += imageData.data[pixelOffset];
        colorCounter.g += imageData.data[pixelOffset + 1];
        colorCounter.b += imageData.data[pixelOffset + 2];
        colorCounter.a += imageData.data[pixelOffset + 3];
        colorCounter.n++;
      }
    }
    return colorCounts;
  }
  initColorCounts(numberOfColors) {
    const colorCounts = [];
    for (let i = 0; i < numberOfColors; i++) {
      colorCounts[i] = { r: 0, g: 0, b: 0, a: 0, n: 0 };
    }
    return colorCounts;
  }
  /**
   * find closest color from palette by measuring (rectilinear) color distance between this pixel and all palette colors
   * @param palette
   * @param color
   * @param pixelOffset
   * @returns
   */
  findClosestPaletteColorIx(imageData, pixelOffset, palette) {
    let closestColorIx = 0;
    let closestDistance = 1024;
    for (let colorIx = 0; colorIx < palette.length; colorIx++) {
      const color = palette[colorIx];
      const distance = color.calculateDistanceToPixelInArray(imageData.data, pixelOffset);
      if (distance >= closestDistance) {
        continue;
      }
      closestDistance = distance;
      closestColorIx = colorIx;
    }
    return closestColorIx;
  }
};
var Trajectory;
(function(Trajectory2) {
  Trajectory2[Trajectory2["RIGHT"] = 0] = "RIGHT";
  Trajectory2[Trajectory2["DOWN_RIGHT"] = 1] = "DOWN_RIGHT";
  Trajectory2[Trajectory2["DOWN"] = 2] = "DOWN";
  Trajectory2[Trajectory2["DOWN_LEFT"] = 3] = "DOWN_LEFT";
  Trajectory2[Trajectory2["LEFT"] = 4] = "LEFT";
  Trajectory2[Trajectory2["UP_LEFT"] = 5] = "UP_LEFT";
  Trajectory2[Trajectory2["UP"] = 6] = "UP";
  Trajectory2[Trajectory2["UP_RIGHT"] = 7] = "UP_RIGHT";
  Trajectory2[Trajectory2["NONE"] = 0] = "NONE";
})(Trajectory || (Trajectory = {}));
var InterpolationMode;
(function(InterpolationMode2) {
  InterpolationMode2["OFF"] = "off";
  InterpolationMode2["INTERPOLATE"] = "interpolate";
})(InterpolationMode || (InterpolationMode = {}));
var PointInterpolator = class {
  interpolate(mode, paths, enhanceRightAngle) {
    const interpolatedPaths = [];
    for (const path of paths) {
      const interpolatedPoints = this.interpolatePointsUsingMode(mode, path.points, enhanceRightAngle);
      const interpolatedPath = {
        points: interpolatedPoints,
        boundingBox: path.boundingBox,
        childHoles: path.childHoles,
        isHole: path.isHole
      };
      interpolatedPaths.push(interpolatedPath);
    }
    return interpolatedPaths;
  }
  interpolatePointsUsingMode(mode, edgePoints, enhanceRightAngle) {
    switch (mode) {
      case InterpolationMode.OFF:
        return edgePoints.map((ep, ix) => this.trajectoryPointFromEdgePoint(edgePoints, ix));
      default:
      case InterpolationMode.INTERPOLATE:
        return this.buildInterpolatedPoints(edgePoints, enhanceRightAngle);
    }
  }
  trajectoryPointFromEdgePoint(points, pointIx) {
    const edgePoint = points[pointIx];
    const nextIx = (pointIx + 1) % points.length;
    const nextPoint = points[nextIx];
    return {
      x: edgePoint.x,
      y: edgePoint.y,
      data: this.geTrajectory(edgePoint.x, edgePoint.y, nextPoint.x, nextPoint.y)
    };
  }
  buildInterpolatedPoints(edgePoints, enhanceRightAngle) {
    const interpolatedPoints = [];
    for (let pointIx = 0; pointIx < edgePoints.length; pointIx++) {
      if (enhanceRightAngle && this.isRightAngle(edgePoints, pointIx)) {
        const cornerPoint = this.buildCornerPoint(edgePoints, pointIx);
        this.updateLastPointTrajectory(interpolatedPoints, edgePoints[pointIx]);
        interpolatedPoints.push(cornerPoint);
      }
      const midPoint = this.interpolateNextTwoPoints(edgePoints, pointIx);
      interpolatedPoints.push(midPoint);
    }
    return interpolatedPoints;
  }
  updateLastPointTrajectory(points, referencePoint) {
    if (points.length === 0) {
      return;
    }
    const lastPointIx = points.length - 1;
    const lastPoint = points[lastPointIx];
    lastPoint.data = this.geTrajectory(lastPoint.x, lastPoint.y, referencePoint.x, referencePoint.y);
  }
  interpolateNextTwoPoints(points, pointIx) {
    const totalPoints = points.length;
    const nextIx1 = (pointIx + 1) % totalPoints;
    const nextIx2 = (pointIx + 2) % totalPoints;
    const currentPoint = points[pointIx];
    const nextPoint = points[nextIx1];
    const nextNextPoint = points[nextIx2];
    const midX = (currentPoint.x + nextPoint.x) / 2;
    const midY = (currentPoint.y + nextPoint.y) / 2;
    const nextMidX = (nextPoint.x + nextNextPoint.x) / 2;
    const nextMidY = (nextPoint.y + nextNextPoint.y) / 2;
    return {
      x: midX,
      y: midY,
      data: this.geTrajectory(midX, midY, nextMidX, nextMidY)
    };
  }
  isRightAngle(points, pointIx) {
    const totalPoints = points.length;
    const currentPoint = points[pointIx];
    const nextIx1 = (pointIx + 1) % totalPoints;
    const nextIx2 = (pointIx + 2) % totalPoints;
    const prevIx1 = (pointIx - 1 + totalPoints) % totalPoints;
    const prevIx2 = (pointIx - 2 + totalPoints) % totalPoints;
    return currentPoint.x === points[prevIx2].x && currentPoint.x === points[prevIx1].x && currentPoint.y === points[nextIx1].y && currentPoint.y === points[nextIx2].y || currentPoint.y === points[prevIx2].y && currentPoint.y === points[prevIx1].y && currentPoint.x === points[nextIx1].x && currentPoint.x === points[nextIx2].x;
  }
  buildCornerPoint(points, pointIx) {
    const nextIx1 = (pointIx + 1) % points.length;
    const currentPoint = points[pointIx];
    const nextPoint = points[nextIx1];
    const midX = (currentPoint.x + nextPoint.x) / 2;
    const midY = (currentPoint.y + nextPoint.y) / 2;
    const trajectory = this.geTrajectory(currentPoint.x, currentPoint.y, midX, midY);
    return {
      x: currentPoint.x,
      y: currentPoint.y,
      data: trajectory
    };
  }
  geTrajectory(x1, y1, x2, y2) {
    if (x1 < x2) {
      if (y1 < y2) {
        return Trajectory.DOWN_RIGHT;
      }
      if (y1 > y2) {
        return Trajectory.UP_RIGHT;
      }
      return Trajectory.RIGHT;
    } else if (x1 > x2) {
      if (y1 < y2) {
        return Trajectory.DOWN_LEFT;
      }
      if (y1 > y2) {
        return Trajectory.UP_LEFT;
      }
      return Trajectory.LEFT;
    } else {
      if (y1 < y2) {
        return Trajectory.DOWN;
      }
      if (y1 > y2) {
        return Trajectory.UP;
      }
    }
    return Trajectory.NONE;
  }
};
var TrimMode;
(function(TrimMode2) {
  TrimMode2["OFF"] = "off";
  TrimMode2["KEEP_RATIO"] = "ratio";
  TrimMode2["ALL"] = "all";
})(TrimMode || (TrimMode = {}));
var FillStyle;
(function(FillStyle2) {
  FillStyle2["FILL"] = "fill";
  FillStyle2["STROKE"] = "stroke";
  FillStyle2["STROKE_FILL"] = "stroke+fill";
})(FillStyle || (FillStyle = {}));
var SvgDrawerDefaultOptions = {
  strokeWidth: 1,
  lineFilter: false,
  scale: 1,
  decimalPlaces: 1,
  viewBox: true,
  desc: false,
  segmentEndpointRadius: 0,
  curveControlPointRadius: 0,
  fillStyle: FillStyle.STROKE_FILL,
  trim: TrimMode.OFF
};
var CreatePaletteMode;
(function(CreatePaletteMode2) {
  CreatePaletteMode2["GENERATE"] = "generate";
  CreatePaletteMode2["SAMPLE"] = "sample";
  CreatePaletteMode2["SCAN"] = "scan";
  CreatePaletteMode2["PALETTE"] = "palette";
})(CreatePaletteMode || (CreatePaletteMode = {}));
var LayeringMode;
(function(LayeringMode2) {
  LayeringMode2[LayeringMode2["SEQUENTIAL"] = 1] = "SEQUENTIAL";
  LayeringMode2[LayeringMode2["PARALLEL"] = 2] = "PARALLEL";
})(LayeringMode || (LayeringMode = {}));
var Options;
(function(Options2) {
  function buildFrom(options) {
    return Object.assign({}, defaultOptions, options ?? {});
  }
  Options2.buildFrom = buildFrom;
  const defaultOptions = Object.assign(SvgDrawerDefaultOptions, {
    // Tracing
    lineErrorMargin: 1,
    curveErrorMargin: 1,
    minShapeOutline: 8,
    enhanceRightAngles: true,
    // Color quantization
    colorSamplingMode: CreatePaletteMode.SCAN,
    palette: null,
    numberOfColors: 16,
    minColorQuota: 0,
    colorClusteringCycles: 3,
    colorDistanceBuffering: ColorDistanceBuffering.REASONABLE,
    // Layering method
    layeringMode: LayeringMode.PARALLEL,
    interpolation: InterpolationMode.INTERPOLATE,
    // Blur
    blurRadius: 0,
    blurDelta: 20,
    sharpen: false,
    sharpenThreshold: 20
  });
  const asPresets = (o) => o;
  Options2.Presets = asPresets({
    default: defaultOptions,
    posterized1: { colorSamplingMode: CreatePaletteMode.GENERATE, numberOfColors: 2 },
    posterized2: { numberOfColors: 4, blurRadius: 5 },
    curvy: { lineErrorMargin: 0.01, lineFilter: true, enhanceRightAngles: false },
    sharp: { curveErrorMargin: 0.01, lineFilter: false },
    detailed: { minShapeOutline: 0, decimalPlaces: 2, lineErrorMargin: 0.5, curveErrorMargin: 0.5, numberOfColors: 64 },
    smoothed: { blurRadius: 5, blurDelta: 64 },
    grayscale: { colorSamplingMode: CreatePaletteMode.GENERATE, colorClusteringCycles: 1, numberOfColors: 7 },
    fixedpalette: { colorSamplingMode: CreatePaletteMode.GENERATE, colorClusteringCycles: 1, numberOfColors: 27 },
    randomsampling1: { colorSamplingMode: CreatePaletteMode.SAMPLE, numberOfColors: 8 },
    randomsampling2: { colorSamplingMode: CreatePaletteMode.SAMPLE, numberOfColors: 64 },
    artistic1: { colorSamplingMode: CreatePaletteMode.GENERATE, colorClusteringCycles: 1, minShapeOutline: 0, blurRadius: 5, blurDelta: 64, lineErrorMargin: 0.01, lineFilter: true, numberOfColors: 16, strokeWidth: 2 },
    artistic2: { curveErrorMargin: 0.01, colorSamplingMode: CreatePaletteMode.GENERATE, colorClusteringCycles: 1, numberOfColors: 4, strokeWidth: 0 },
    artistic3: { curveErrorMargin: 10, lineErrorMargin: 10, numberOfColors: 8 },
    artistic4: { curveErrorMargin: 10, lineErrorMargin: 10, numberOfColors: 64, blurRadius: 5, blurDelta: 256, strokeWidth: 2 },
    posterized3: {
      lineErrorMargin: 1,
      curveErrorMargin: 1,
      minShapeOutline: 20,
      enhanceRightAngles: true,
      colorSamplingMode: CreatePaletteMode.GENERATE,
      numberOfColors: 3,
      minColorQuota: 0,
      colorClusteringCycles: 3,
      blurRadius: 3,
      blurDelta: 20,
      strokeWidth: 0,
      lineFilter: false,
      decimalPlaces: 1,
      palette: [{ r: 0, g: 0, b: 100, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }]
    }
  });
})(Options || (Options = {}));
var SPEC_PALETTE = [
  { r: 0, g: 0, b: 0, a: 255 },
  { r: 128, g: 128, b: 128, a: 255 },
  { r: 0, g: 0, b: 128, a: 255 },
  { r: 64, g: 64, b: 128, a: 255 },
  { r: 192, g: 192, b: 192, a: 255 },
  { r: 255, g: 255, b: 255, a: 255 },
  { r: 128, g: 128, b: 192, a: 255 },
  { r: 0, g: 0, b: 192, a: 255 },
  { r: 128, g: 0, b: 0, a: 255 },
  { r: 128, g: 64, b: 64, a: 255 },
  { r: 128, g: 0, b: 128, a: 255 },
  { r: 168, g: 168, b: 168, a: 255 },
  { r: 192, g: 128, b: 128, a: 255 },
  { r: 192, g: 0, b: 0, a: 255 },
  { r: 255, g: 255, b: 255, a: 255 },
  { r: 0, g: 128, b: 0, a: 255 }
];
var DivRenderer = class {
  // Helper function: Drawing all edge node layers into a container
  drawLayersToDiv(edgeRasters, scale, parentId) {
    scale = scale || 1;
    var w, h, i, j, k;
    var div;
    if (parentId) {
      div = document.getElementById(parentId);
      if (!div) {
        div = document.createElement("div");
        div.id = parentId;
        document.body.appendChild(div);
      }
    } else {
      div = document.createElement("div");
      document.body.appendChild(div);
    }
    for (k in edgeRasters) {
      if (!edgeRasters.hasOwnProperty(k)) {
        continue;
      }
      w = edgeRasters[k][0].length;
      h = edgeRasters[k].length;
      const canvas = document.createElement("canvas");
      canvas.width = w * scale;
      canvas.height = h * scale;
      const context = this.getCanvasContext(canvas);
      const palette = SPEC_PALETTE;
      for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
          const colorIndex = edgeRasters[k][j][i] % palette.length;
          const color = palette[colorIndex];
          context.fillStyle = this.toRgbaLiteral(color);
          context.fillRect(i * scale, j * scale, scale, scale);
        }
      }
      div.appendChild(canvas);
    }
  }
  // Convert color object to rgba string
  toRgbaLiteral(c) {
    return "rgba(" + c.r + "," + c.g + "," + c.b + "," + c.a + ")";
  }
  // TODO check duplication
  getCanvasContext(canvas) {
    const context = canvas.getContext("2d");
    if (!context) {
      throw new Error("Could not read canvas");
    }
    return context;
  }
};
var EdgeRasterBuilder = class {
  /**
   *
   * Builds one layer for each color in the given color index.
   *
   * @param colorIndex
   * @returns
   */
  static buildForColors(colorIndex) {
    const rows = colorIndex.rows;
    const height = rows.length;
    const width = rows[0].length;
    const edgeRasters = [];
    for (let colorId = 0; colorId < colorIndex.palette.length; colorId++) {
      edgeRasters[colorId] = [];
      for (let h = 0; h < height; h++) {
        edgeRasters[colorId][h] = new Array(width).fill(0);
      }
    }
    let n1, n2, n3, n4, n5, n6, n7, n8;
    for (let h = 1; h < height - 1; h++) {
      for (let w = 1; w < width - 1; w++) {
        const colorId = rows[h][w];
        n1 = rows[h - 1][w - 1] === colorId ? 1 : 0;
        n2 = rows[h - 1][w] === colorId ? 1 : 0;
        n3 = rows[h - 1][w + 1] === colorId ? 1 : 0;
        n4 = rows[h][w - 1] === colorId ? 1 : 0;
        n5 = rows[h][w + 1] === colorId ? 1 : 0;
        n6 = rows[h + 1][w - 1] === colorId ? 1 : 0;
        n7 = rows[h + 1][w] === colorId ? 1 : 0;
        n8 = rows[h + 1][w + 1] === colorId ? 1 : 0;
        const edgeRaster = edgeRasters[colorId];
        edgeRaster[h + 1][w + 1] = 1 + n5 * 2 + n8 * 4 + n7 * 8;
        if (!n4) {
          edgeRaster[h + 1][w] = 0 + 2 + n7 * 4 + n6 * 8;
        }
        if (!n2) {
          edgeRaster[h][w + 1] = 0 + n3 * 2 + n5 * 4 + 8;
        }
        if (!n1) {
          edgeRaster[h][w] = 0 + n2 * 2 + 4 + n4 * 8;
        }
      }
    }
    return edgeRasters;
  }
  // 2. Layer separation and edge detection
  // Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )
  // 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓
  // 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓
  //     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
  static buildForColor(colorData, colorId) {
    const rows = colorData.rows;
    const height = rows.length;
    const width = rows[0].length;
    const edgeRaster = [];
    for (let j = 0; j < height; j++) {
      edgeRaster[j] = new Array(width).fill(0);
    }
    for (let h = 1; h < height; h++) {
      for (let w = 1; w < width; w++) {
        edgeRaster[h][w] = (rows[h - 1][w - 1] === colorId ? 1 : 0) + (rows[h - 1][w] === colorId ? 2 : 0) + (rows[h][w - 1] === colorId ? 8 : 0) + (rows[h][w] === colorId ? 4 : 0);
      }
    }
    return edgeRaster;
  }
};
var PATH_SCAN_COMBINED_LOOKUP = [
  [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]],
  [[0, 1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [0, 2, -1, 0]],
  [[-1, -1, -1, -1], [-1, -1, -1, -1], [0, 1, 0, -1], [0, 0, 1, 0]],
  [[0, 0, 1, 0], [-1, -1, -1, -1], [0, 2, -1, 0], [-1, -1, -1, -1]],
  [[-1, -1, -1, -1], [0, 0, 1, 0], [0, 3, 0, 1], [-1, -1, -1, -1]],
  [[13, 3, 0, 1], [13, 2, -1, 0], [7, 1, 0, -1], [7, 0, 1, 0]],
  [[-1, -1, -1, -1], [0, 1, 0, -1], [-1, -1, -1, -1], [0, 3, 0, 1]],
  [[0, 3, 0, 1], [0, 2, -1, 0], [-1, -1, -1, -1], [-1, -1, -1, -1]],
  [[0, 3, 0, 1], [0, 2, -1, 0], [-1, -1, -1, -1], [-1, -1, -1, -1]],
  [[-1, -1, -1, -1], [0, 1, 0, -1], [-1, -1, -1, -1], [0, 3, 0, 1]],
  [[11, 1, 0, -1], [14, 0, 1, 0], [14, 3, 0, 1], [11, 2, -1, 0]],
  [[-1, -1, -1, -1], [0, 0, 1, 0], [0, 3, 0, 1], [-1, -1, -1, -1]],
  [[0, 0, 1, 0], [-1, -1, -1, -1], [0, 2, -1, 0], [-1, -1, -1, -1]],
  [[-1, -1, -1, -1], [-1, -1, -1, -1], [0, 1, 0, -1], [0, 0, 1, 0]],
  [[0, 1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [0, 2, -1, 0]],
  [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]
  // arr[py][px]===15 is invalid
];
var AreaScanner = class {
  /**
   * 3. Walking through an edge node array, discarding edge node types 0 and 15 and creating paths from the rest.
   *  Walk directions: 0 > ; 1 ^ ; 2 < ; 3 v
   * @param edgeRaster
   * @returns
   */
  scan(edgeRaster, pathMinLength) {
    const width = edgeRaster[0].length;
    const height = edgeRaster.length;
    const paths = [];
    let pathIx = 0;
    for (let h = 0; h < height; h++) {
      for (let w = 0; w < width; w++) {
        const edge = edgeRaster[h][w];
        if (edge !== 4 && edge !== 11) {
          continue;
        }
        let px = w;
        let py = h;
        const pointedArea = {
          points: [],
          boundingBox: [px, py, px, py],
          childHoles: [],
          isHole: edge === 11
        };
        paths[pathIx] = pointedArea;
        let areaClosed = false;
        let direction = 1;
        while (!areaClosed) {
          const edgeType = edgeRaster[py][px];
          this.addPointToArea(pointedArea, px - 1, py - 1, edgeType);
          const lookupRow = PATH_SCAN_COMBINED_LOOKUP[edgeType][direction];
          edgeRaster[py][px] = lookupRow[0];
          direction = lookupRow[1];
          px += lookupRow[2];
          py += lookupRow[3];
          if (px - 1 === pointedArea.points[0].x && py - 1 === pointedArea.points[0].y) {
            areaClosed = true;
            if (pointedArea.points.length < pathMinLength) {
              paths.pop();
              continue;
            }
            if (pointedArea.isHole) {
              const parentId = this.findParentId(pointedArea, paths, pathIx, width, height);
              paths[parentId].childHoles.push(pathIx);
            }
            pathIx++;
          }
        }
      }
    }
    return paths;
  }
  addPointToArea(area, x, y, edgeType) {
    const point = { x, y, data: edgeType };
    if (x < area.boundingBox[0]) {
      area.boundingBox[0] = x;
    }
    if (y < area.boundingBox[1]) {
      area.boundingBox[1] = y;
    }
    if (x > area.boundingBox[2]) {
      area.boundingBox[2] = x;
    }
    if (y > area.boundingBox[3]) {
      area.boundingBox[3] = y;
    }
    return area.points.push(point);
  }
  findParentId(path, paths, maxPath, w, h) {
    let parentId = 0;
    let parentbbox = [-1, -1, w + 1, h + 1];
    for (let parentIx = 0; parentIx < maxPath; parentIx++) {
      const parentPath = paths[parentIx];
      if (!parentPath.isHole && this.boundingBoxIncludes(parentPath.boundingBox, path.boundingBox) && this.boundingBoxIncludes(parentbbox, parentPath.boundingBox) && this.pointInPolygon(path.points[0], parentPath.points)) {
        parentId = parentIx;
        parentbbox = parentPath.boundingBox;
      }
    }
    return parentId;
  }
  boundingBoxIncludes(parentbbox, childbbox) {
    return parentbbox[0] < childbbox[0] && parentbbox[1] < childbbox[1] && parentbbox[2] > childbbox[2] && parentbbox[3] > childbbox[3];
  }
  // Point in polygon test
  pointInPolygon(point, path) {
    let isIn = false;
    for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
      isIn = path[i].y > point.y !== path[j].y > point.y && point.x < (path[j].x - path[i].x) * (point.y - path[i].y) / (path[j].y - path[i].y) + path[i].x ? !isIn : isIn;
    }
    return isIn;
  }
};
var SvgLineAttributes;
(function(SvgLineAttributes2) {
  function toString(la) {
    const str = `${la.type} ${la.x1} ${la.y1} ${la.x2} ${la.y2}`;
    if (la.type === "L") {
      return str;
    }
    return str + ` ${la.x3} ${la.y3}`;
  }
  SvgLineAttributes2.toString = toString;
})(SvgLineAttributes || (SvgLineAttributes = {}));
var PathTracer = class {
  // 5. tracepath() : recursively trying to fit straight and quadratic spline segments on the 8 direction internode path
  // 5.1. Find sequences of points with only 2 segment types
  // 5.2. Fit a straight line on the sequence
  // 5.3. If the straight line fails (distance error > lineErrorMargin), find the point with the biggest error
  // 5.4. Fit a quadratic spline through errorpoint (project this to get controlpoint), then measure errors on every point in the sequence
  // 5.5. If the spline fails (distance error > curveErrorMargin), find the point with the biggest error, set splitpoint = fitting point
  // 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences
  trace(path, lineErrorMargin, curveErrorMargin) {
    const pathCommands = [];
    const points = [].concat(path.points);
    points.push(points[0]);
    for (let sequenceStartIx = 0; sequenceStartIx < points.length - 1; ) {
      const nextSequenceStartIx = this.findNextSequenceStartIx(points, sequenceStartIx);
      const commandSequence = this.getPathCommandsOfSequence(points, lineErrorMargin, curveErrorMargin, sequenceStartIx, nextSequenceStartIx);
      pathCommands.push(...commandSequence);
      sequenceStartIx = nextSequenceStartIx;
    }
    return {
      lineAttributes: pathCommands,
      boundingBox: path.boundingBox,
      childHoles: path.childHoles,
      isHole: path.isHole
    };
  }
  /**
   * Find sequence of points with 2 trajectories.
   *
   * @param points
   * @param startIx
   * @returns The index where the next sequence starts
   */
  findNextSequenceStartIx(points, startIx) {
    const startTrajectory = points[startIx].data;
    let nextIx = startIx + 1;
    let nextPoint = points[nextIx];
    let secondTrajectory = null;
    while ((nextPoint.data === startTrajectory || nextPoint.data === secondTrajectory || secondTrajectory === null) && nextIx < points.length - 1) {
      if (nextPoint.data !== startTrajectory && secondTrajectory === null) {
        secondTrajectory = nextPoint.data;
      }
      nextIx++;
      nextPoint = points[nextIx];
    }
    return nextIx === points.length - 2 ? nextIx + 1 : nextIx;
  }
  // 5.2. - 5.6. recursively fitting a straight or quadratic line segment on this sequence of path nodes,
  // called from tracepath()
  getPathCommandsOfSequence(points, lineErrorMargin, curveErrorMargin, sequenceStartIx, sequenceEndIx) {
    if (sequenceEndIx > points.length || sequenceEndIx < 0) {
      return [];
    }
    const isLineResult = this.checkSequenceFitsLine(points, lineErrorMargin, sequenceStartIx, sequenceEndIx);
    if (typeof isLineResult === "object") {
      return [isLineResult];
    }
    const isCurveResult = this.checkSequenceFitsCurve(points, curveErrorMargin, sequenceStartIx, sequenceEndIx, isLineResult);
    if (typeof isCurveResult === "object") {
      return [isCurveResult];
    }
    const splitPoint = isLineResult;
    const seqSplit1 = this.getPathCommandsOfSequence(points, lineErrorMargin, curveErrorMargin, sequenceStartIx, splitPoint);
    const seqSplit2 = this.getPathCommandsOfSequence(points, lineErrorMargin, curveErrorMargin, splitPoint, sequenceEndIx);
    return seqSplit1.concat(seqSplit2);
  }
  checkSequenceFitsLine(points, lineErrorMargin, sequenceStartIx, sequenceEndIx) {
    const sequenceLength = sequenceEndIx - sequenceStartIx;
    const startPoint = points[sequenceStartIx];
    const endPoint = points[sequenceEndIx];
    const gainX = (endPoint.x - startPoint.x) / sequenceLength;
    const gainY = (endPoint.y - startPoint.y) / sequenceLength;
    let isStraightLine = true;
    let maxDiffIx = sequenceStartIx;
    let maxDiff = 0;
    for (let pointIx = sequenceStartIx + 1; pointIx < sequenceEndIx; pointIx++) {
      const subsequenceLength = pointIx - sequenceStartIx;
      const expectedX = startPoint.x + subsequenceLength * gainX;
      const expectedY = startPoint.y + subsequenceLength * gainY;
      const point = points[pointIx];
      const diff = (point.x - expectedX) * (point.x - expectedX) + (point.y - expectedY) * (point.y - expectedY);
      if (diff > lineErrorMargin) {
        isStraightLine = false;
      }
      if (diff > maxDiff) {
        maxDiffIx = pointIx;
        maxDiff = diff;
      }
    }
    if (!isStraightLine) {
      return maxDiffIx;
    }
    return {
      type: "L",
      x1: startPoint.x,
      y1: startPoint.y,
      x2: endPoint.x,
      y2: endPoint.y
    };
  }
  checkSequenceFitsCurve(points, curveErrorMargin, sequenceStartIx, sequenceEndIx, turningPointIx) {
    const sequenceLength = sequenceEndIx - sequenceStartIx;
    const startPoint = points[sequenceStartIx];
    const endPoint = points[sequenceEndIx];
    let isCurve = true;
    let maxDiff = 0;
    let maxDiffIx = sequenceStartIx;
    let subsequenceLength = turningPointIx - sequenceStartIx, t = subsequenceLength / sequenceLength, t1 = (1 - t) * (1 - t), t2 = 2 * (1 - t) * t, t3 = t * t;
    const qControlPointX = (t1 * startPoint.x + t3 * endPoint.x - points[turningPointIx].x) / -t2;
    const qControlPointY = (t1 * startPoint.y + t3 * endPoint.y - points[turningPointIx].y) / -t2;
    for (let pointIx = sequenceStartIx + 1; pointIx != sequenceEndIx; pointIx = (pointIx + 1) % points.length) {
      subsequenceLength = pointIx - sequenceStartIx;
      t = subsequenceLength / sequenceLength;
      t1 = (1 - t) * (1 - t);
      t2 = 2 * (1 - t) * t;
      t3 = t * t;
      const px = t1 * startPoint.x + t2 * qControlPointX + t3 * endPoint.x;
      const py = t1 * startPoint.y + t2 * qControlPointY + t3 * endPoint.y;
      const point = points[pointIx];
      const diff = (point.x - px) * (point.x - px) + (point.y - py) * (point.y - py);
      if (diff > curveErrorMargin) {
        isCurve = false;
      }
      if (diff > maxDiff) {
        maxDiffIx = pointIx;
        maxDiff = diff;
      }
    }
    if (!isCurve) {
      return maxDiffIx;
    }
    return {
      type: "Q",
      x1: startPoint.x,
      y1: startPoint.y,
      x2: qControlPointX,
      y2: qControlPointY,
      x3: endPoint.x,
      y3: endPoint.y
    };
  }
};
var TraceDataTrimmer;
(function(TraceDataTrimmer2) {
  function trim(traceData, strokeWidth, keepAspectRatio, verbose = false) {
    const offsets = getOffsets(traceData, strokeWidth);
    if (keepAspectRatio) {
      applyAspectRatio(offsets, traceData);
    }
    if (offsets.minX === 0 && offsets.maxX === traceData.width && offsets.minY === 0 && offsets.maxY === traceData.height) {
      return;
    }
    verbose && console.log(`Trimming x[${offsets.minX}|${offsets.maxX}]/${traceData.width}, y[${offsets.minY}|${offsets.maxY}]/${traceData.height}`);
    updateData(traceData, offsets);
  }
  TraceDataTrimmer2.trim = trim;
  function getOffsets(traceData, strokeWidth) {
    let minX = traceData.width, minY = traceData.height, maxX = 0, maxY = 0;
    for (let colorId = 0; colorId < traceData.areasByColor.length; colorId++) {
      const color = traceData.colors[colorId];
      if (color.a === 0) {
        continue;
      }
      const colorArea = traceData.areasByColor[colorId];
      for (const area of colorArea) {
        for (const line of area.lineAttributes) {
          const isLineQ = line.type === "Q";
          minX = Math.min(minX, line.x1, line.x2, isLineQ ? line.x3 : minX);
          maxX = Math.max(maxX, line.x1, line.x2, isLineQ ? line.x3 : 0);
          minY = Math.min(minY, line.y1, line.y2, isLineQ ? line.y3 : minY);
          maxY = Math.max(maxY, line.y1, line.y2, isLineQ ? line.y3 : 0);
        }
      }
    }
    const strokeBorder = Math.floor(strokeWidth / 2);
    minX -= strokeBorder;
    minY -= strokeBorder;
    maxX += strokeBorder;
    maxY += strokeBorder;
    return { minX, maxX, minY, maxY };
  }
  function applyAspectRatio(offsets, traceData) {
    const trimmedWidth = offsets.maxX - offsets.minX;
    const trimmedHeight = offsets.maxY - offsets.minY;
    const oldWidth = traceData.width;
    const oldHeight = traceData.height;
    const expectedTrimmedWidth = Math.ceil(trimmedHeight * oldWidth / oldHeight);
    if (trimmedWidth === expectedTrimmedWidth) {
      return;
    }
    if (expectedTrimmedWidth > trimmedWidth) {
      const diff2 = (expectedTrimmedWidth - trimmedWidth) / 2;
      offsets.minX -= Math.ceil(diff2);
      offsets.maxX += Math.floor(diff2);
      return;
    }
    const expectedTrimmedHeight = Math.ceil(trimmedWidth * oldHeight / oldWidth);
    const diff = (expectedTrimmedHeight - trimmedHeight) / 2;
    offsets.minY -= Math.ceil(diff);
    offsets.maxY += Math.floor(diff);
  }
  function updateData(traceData, offsets) {
    const { minX, maxX, minY, maxY } = offsets;
    for (const colorArea of traceData.areasByColor) {
      for (const area of colorArea) {
        for (const lineAttribute of area.lineAttributes) {
          lineAttribute.x1 -= minX;
          lineAttribute.x2 -= minX;
          lineAttribute.y1 -= minY;
          lineAttribute.y2 -= minY;
          if (lineAttribute.type === "Q") {
            lineAttribute.x3 -= minX;
            lineAttribute.y3 -= minY;
          }
        }
      }
    }
    traceData.height = maxY - minY;
    traceData.width = maxX - minX;
  }
})(TraceDataTrimmer || (TraceDataTrimmer = {}));
var SvgDrawer = class {
  options;
  useStroke;
  useFill;
  constructor(options) {
    this.options = Object.assign({}, SvgDrawerDefaultOptions, options);
    this.useFill = [FillStyle.FILL, FillStyle.STROKE_FILL].includes(this.options.fillStyle);
    this.useStroke = [FillStyle.STROKE, FillStyle.STROKE_FILL].includes(this.options.fillStyle);
  }
  fixValue(val) {
    if (this.options.scale !== 1) {
      val *= this.options.scale;
    }
    if (this.options.decimalPlaces === -1) {
      return val;
    }
    return +val.toFixed(this.options.decimalPlaces);
  }
  draw(traceData) {
    this.init(traceData);
    const tags = [];
    for (let colorId = 0; colorId < traceData.areasByColor.length; colorId++) {
      for (let areaIx = 0; areaIx < traceData.areasByColor[colorId].length; areaIx++) {
        if (traceData.areasByColor[colorId][areaIx].isHole) {
          continue;
        }
        tags.push(...this.buildSegmentTags(traceData, colorId, areaIx));
      }
    }
    if (this.options.verbose) {
      console.log(`Adding ${tags.length} <path> tags to SVG.`);
    }
    return this.buildSvgTag(traceData, tags);
  }
  init(traceData) {
    if (this.options.trim !== TrimMode.OFF) {
      const strokeWidth = this.options.fillStyle === FillStyle.FILL ? 0 : this.options.strokeWidth;
      const keepAspectRatio = this.options.trim === TrimMode.KEEP_RATIO;
      TraceDataTrimmer.trim(traceData, strokeWidth, keepAspectRatio, this.options.verbose);
    }
  }
  /**
   * Builds a <path> tag for each segment.
   *
   * @param traceData
   * @param colorId
   * @param segmentIx
   * @returns
   */
  buildSegmentTags(traceData, colorId, segmentIx) {
    const colorSegments = traceData.areasByColor[colorId];
    const area = colorSegments[segmentIx];
    const color = traceData.colors[colorId];
    if (!this.isValidLine(color, area.lineAttributes)) {
      return [];
    }
    const tags = [];
    const desc = this.options.desc ? this.getDescriptionAttribute(traceData, colorId, segmentIx) : "";
    const tag = this.buildPathTag(area, colorSegments, color, desc);
    tags.push(tag);
    if (this.options.segmentEndpointRadius || this.options.curveControlPointRadius) {
      const controlPoints = this.drawControlOutput(area, colorSegments);
      tags.push(...controlPoints);
    }
    return tags;
  }
  isValidLine(color, lineAttributes) {
    const passesLineFilter = !this.options.lineFilter || lineAttributes.length >= 3;
    return !color.isInvisible() && passesLineFilter;
  }
  getDescriptionAttribute(traceData, colorId, segmentIx) {
    const area = traceData.areasByColor[colorId][segmentIx];
    const isHole = area.isHole ? 1 : 0;
    const color = traceData.colors[colorId];
    const colorStr = `r:${color.r} g:${color.g} b:${color.b}`;
    return this.options.desc ? `desc="colorId:${colorId} segment:${segmentIx} ${colorStr} isHole:${isHole}" ` : "";
  }
  buildPath(segment, colorSegments) {
    const lines = segment.lineAttributes;
    const pathStr = [];
    pathStr.push("M", this.fixValue(lines[0].x1), this.fixValue(lines[0].y1));
    for (const line of lines) {
      pathStr.push(line.type, this.fixValue(line.x2), this.fixValue(line.y2));
      if ("x3" in line) {
        pathStr.push(this.fixValue(line.x3), this.fixValue(line.y3));
      }
    }
    pathStr.push("Z");
    for (const holeIx of segment.childHoles) {
      const holeSegments = colorSegments[holeIx];
      const lastLine = holeSegments.lineAttributes[holeSegments.lineAttributes.length - 1];
      pathStr.push("M");
      if (lastLine.type === "Q") {
        pathStr.push(this.fixValue(lastLine.x3), this.fixValue(lastLine.y3));
      } else {
        pathStr.push(this.fixValue(lastLine.x2), this.fixValue(lastLine.y2));
      }
      for (const holeLine of holeSegments.lineAttributes.reverse()) {
        pathStr.push(holeLine.type);
        if (holeLine.type === "Q") {
          pathStr.push(this.fixValue(holeLine.x2), this.fixValue(holeLine.y2));
        }
        pathStr.push(this.fixValue(holeLine.x1), this.fixValue(holeLine.y1));
      }
      pathStr.push("Z");
    }
    return pathStr.join(" ");
  }
  drawControlOutput(segment, colorSegments) {
    const tags = this.drawControlPoint(segment);
    for (let holeIx of segment.childHoles) {
      const holeSegment = colorSegments[holeIx];
      const holeElements = this.drawControlPoint(holeSegment);
      tags.push(...holeElements);
    }
    return tags;
  }
  drawControlPoint(segment) {
    const tags = [];
    for (const shape of segment.lineAttributes) {
      const isCurve = "x3" in shape;
      if (this.options.segmentEndpointRadius) {
        const endX = isCurve ? shape.x3 : shape.x2;
        const endY = isCurve ? shape.y3 : shape.y2;
        const endPoint = this.buildCircleTag(endX, endY, this.options.segmentEndpointRadius, "white");
        tags.push(endPoint);
      }
      if (isCurve && this.options.curveControlPointRadius) {
        const controlColor = "cyan";
        const lineWidth = this.options.curveControlPointRadius * 0.2;
        tags.push(this.buildCircleTag(shape.x2, shape.y2, this.options.curveControlPointRadius, controlColor), this.buildLineTag(shape.x1, shape.y1, shape.x2, shape.y2, controlColor, lineWidth), this.buildLineTag(shape.x2, shape.y2, shape.x3, shape.y3, controlColor, lineWidth));
      }
    }
    return tags;
  }
  buildSvgTag(traceData, tags) {
    const w = Math.ceil(traceData.width * this.options.scale);
    const h = Math.ceil(traceData.height * this.options.scale);
    const viewBox = this.options.viewBox ? `viewBox="0 0 ${w} ${h}"` : `width="${w}" height="${h}"`;
    const tagString = tags.join("\n ");
    return `<svg ${viewBox} version="1.1" xmlns="http://www.w3.org/2000/svg" desc="Created with imagetracer-ts 1.0.2" >
 ${tagString}
</svg>`;
  }
  buildPathTag(area, colorSegments, color, desc = "") {
    const d = this.buildPath(area, colorSegments);
    const colorAttributes = this.buildColorAttributes(color, area);
    return `<path ${desc}${colorAttributes}d="${d}" />`;
  }
  buildCircleTag(x, y, r, fill) {
    const cx = this.fixValue(x);
    const cy = this.fixValue(y);
    const strokeWidth = r * 0.2;
    return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" stroke-width="${strokeWidth}" stroke="black" />`;
  }
  buildLineTag(x1, y1, x2, y2, color, strokeWidth) {
    const tx1 = this.fixValue(x1), ty1 = this.fixValue(y1), tx2 = this.fixValue(x2), ty2 = this.fixValue(y2);
    return `<line x1="${tx1}" y1="${ty1}" x2="${tx2}" y2="${ty2}" stroke-width="${strokeWidth}" stroke="${color}" />`;
  }
  buildColorAttributes(c, area) {
    const colorString = this.colorToRgbString(c);
    const fill = this.useFill ? colorString : "none";
    let attributes = `fill="${fill}" `;
    if (this.useStroke) {
      attributes += `stroke="${colorString}" stroke-width="${this.options.strokeWidth}" `;
    }
    const opacity = (c.a / 255).toPrecision(1);
    if (opacity !== "1") {
      attributes += `opacity="${opacity}" `;
    }
    return attributes;
  }
  colorToRgbString(color) {
    return `rgb(${color.r},${color.g},${color.b})`;
  }
};
function getColorQuantizeFunction(mode, palette = null) {
  switch (mode) {
    case CreatePaletteMode.GENERATE:
      return (imageData, numberOfColors) => generatePalette(numberOfColors);
    case CreatePaletteMode.SAMPLE:
      return samplePaletteRandom;
    case CreatePaletteMode.PALETTE:
      if (!palette || palette.length === 0) {
        throw new Error("No color palette in options but mode is set to palette");
      }
      return (imageData, numberOfColors) => palette.map(RgbColor.fromRgbColorData);
    case CreatePaletteMode.SCAN:
    default:
      return samplePaletteDeterministic;
  }
}
function generatePalette(numberOfColors) {
  if (numberOfColors < 8) {
    return generateGrayscalePalette(numberOfColors);
  }
  return generateColorCubePalette(numberOfColors);
}
function generateColorCubePalette(numberOfColors) {
  const palette = [];
  const colorsPerEdge = Math.floor(Math.pow(numberOfColors, 1 / 3));
  const colorStep = Math.floor(255 / (colorsPerEdge - 1));
  for (let numReds = 0, r = 0; numReds < colorsPerEdge; numReds++, r += colorStep) {
    for (let numGreens = 0, g = 0; numGreens < colorsPerEdge; numGreens++, g += colorStep) {
      for (let numBlues = 0, b = 0; numBlues < colorsPerEdge; numBlues++, b += colorStep) {
        palette.push(new RgbColor(r, g, b));
      }
    }
  }
  const numRandomColors = numberOfColors - palette.length;
  for (let i = 0; i < numRandomColors; i++) {
    palette.push(RgbColor.createRandomColor());
  }
  return palette;
}
function generateGrayscalePalette(numberOfColors) {
  const palette = [];
  const grayStep = Math.floor(255 / (numberOfColors - 1));
  for (let i = 0; i < numberOfColors; i++) {
    const shade = i * grayStep;
    const color = new RgbColor(shade, shade, shade);
    palette.push(color);
  }
  return palette;
}
function samplePaletteRandom(imageData, numColors) {
  const palette = [];
  const numberOfPixels = imageData.data.length / 4;
  for (let numberOfTries = 4 * numColors; numberOfTries > 0; numberOfTries--) {
    const idx = Math.floor(Math.random() * numberOfPixels);
    const color = RgbColor.fromPixelArray(imageData.data, idx);
    if (palette.some((paletteColor) => paletteColor.equals(color))) {
      continue;
    }
    palette.push(color);
    if (palette.length === numColors) {
      break;
    }
  }
  return palette;
}
function samplePaletteDeterministic(imageData, numColors) {
  const palette = [];
  const stepsPerRow = Math.ceil(Math.sqrt(numColors));
  const stepSizeX = imageData.width / (stepsPerRow + 1);
  const stepSizeY = imageData.height / (stepsPerRow + 1);
  for (let stepY = 1; stepY <= stepsPerRow; stepY++) {
    const widthOffset = stepY * stepSizeY * imageData.width;
    for (let stepX = 1; stepX <= stepsPerRow; stepX++) {
      const pixelIndex = Math.floor(widthOffset + stepX * stepSizeX);
      const color = RgbColor.fromPixelArray(imageData.data, pixelIndex);
      if (palette.some((paletteColor) => color.equals(paletteColor))) {
        continue;
      }
      palette.push(color);
      if (palette.length === numColors) {
        break;
      }
    }
  }
  return palette;
}
var ImageToRgba;
(function(ImageToRgba2) {
  function process(imageData, isVerbose = false) {
    if (isRgba(imageData)) {
      return imageData;
    }
    isVerbose && console.log("Transforming image data from RGB to RGBA");
    const numPixels = imageData.width * imageData.height;
    const rgbaSize = numPixels * 4;
    const rgbaData = new Uint8ClampedArray(rgbaSize);
    for (let pixelIx = 0; pixelIx < numPixels; pixelIx++) {
      const dataPixelOffset = pixelIx * 3;
      const rgbaPixelOffset = pixelIx * 4;
      rgbaData[rgbaPixelOffset + 0] = imageData.data[dataPixelOffset + 0];
      rgbaData[rgbaPixelOffset + 1] = imageData.data[dataPixelOffset + 1];
      rgbaData[rgbaPixelOffset + 2] = imageData.data[dataPixelOffset + 2];
      rgbaData[rgbaPixelOffset + 3] = 255;
    }
    return {
      width: imageData.width,
      height: imageData.height,
      colorSpace: imageData.colorSpace,
      data: rgbaData
    };
  }
  ImageToRgba2.process = process;
  function isRgba(imageData) {
    const numPixels = imageData.width * imageData.height;
    const rgbaSize = numPixels * 4;
    return imageData.data.length >= rgbaSize;
  }
})(ImageToRgba || (ImageToRgba = {}));
var GAUSSIAN_KERNELS = [
  [0.27901, 0.44198, 0.27901],
  [0.135336, 0.228569, 0.272192, 0.228569, 0.135336],
  [0.086776, 0.136394, 0.178908, 0.195843, 0.178908, 0.136394, 0.086776],
  [0.063327, 0.093095, 0.122589, 0.144599, 0.152781, 0.144599, 0.122589, 0.093095, 0.063327],
  [0.049692, 0.069304, 0.089767, 0.107988, 0.120651, 0.125194, 0.120651, 0.107988, 0.089767, 0.069304, 0.049692]
];
var ImageBlurrer = class _ImageBlurrer {
  // Selective Gaussian blur for preprocessing
  static blur(imageData, radius, delta) {
    radius = Math.floor(radius);
    if (radius < 1) {
      return imageData;
    }
    if (radius > 5) {
      radius = 5;
    }
    delta = Math.abs(delta);
    if (delta > 1024) {
      delta = 1024;
    }
    const kernel = GAUSSIAN_KERNELS[radius - 1];
    const output = {
      width: imageData.width,
      height: imageData.height,
      colorSpace: imageData.colorSpace,
      data: new Uint8ClampedArray(imageData.width * imageData.height * 4)
    };
    _ImageBlurrer.blurHorizontally(imageData, radius, kernel, output.data);
    _ImageBlurrer.blurVertically(output, radius, kernel);
    _ImageBlurrer.checkDelta(imageData, output.data, delta);
    return output;
  }
  static blurHorizontally(imageData, radius, kernel, target) {
    for (let rowIx = 0; rowIx < imageData.height; rowIx++) {
      for (let colIx = 0; colIx < imageData.width; colIx++) {
        const pixelId = rowIx * imageData.width + colIx;
        let racc = 0, gacc = 0, bacc = 0, aacc = 0, wacc = 0;
        for (let r = -radius; r <= radius; r++) {
          if (colIx + r < 0 || colIx + r >= imageData.width) {
            continue;
          }
          const idx2 = (pixelId + r) * 4;
          const ratio = kernel[r + radius];
          racc += imageData.data[idx2 + 0] * ratio;
          gacc += imageData.data[idx2 + 1] * ratio;
          bacc += imageData.data[idx2 + 2] * ratio;
          aacc += imageData.data[idx2 + 3] * ratio;
          wacc += ratio;
        }
        const idx = pixelId * 4;
        target[idx + 0] = Math.floor(racc / wacc);
        target[idx + 1] = Math.floor(gacc / wacc);
        target[idx + 2] = Math.floor(bacc / wacc);
        target[idx + 3] = Math.floor(aacc / wacc);
        target[idx + 0];
      }
    }
  }
  static blurVertically(image, radius, kernel) {
    const inputData = new Uint8ClampedArray(image.data);
    for (let rowIx = 0; rowIx < image.height; rowIx++) {
      for (let colIx = 0; colIx < image.width; colIx++) {
        let racc = 0, gacc = 0, bacc = 0, aacc = 0, wacc = 0;
        for (let r = -radius; r <= radius; r++) {
          const rowOffset = rowIx + r;
          if (rowOffset < 0 || rowOffset >= image.height) {
            continue;
          }
          const idx2 = (rowOffset * image.width + colIx) * 4;
          const ratio = kernel[r + radius];
          racc += inputData[idx2 + 0] * ratio;
          gacc += inputData[idx2 + 1] * ratio;
          bacc += inputData[idx2 + 2] * ratio;
          aacc += inputData[idx2 + 3] * ratio;
          wacc += ratio;
        }
        const idx = (rowIx * image.width + colIx) * 4;
        image.data[idx + 0] = Math.floor(racc / wacc);
        image.data[idx + 1] = Math.floor(gacc / wacc);
        image.data[idx + 2] = Math.floor(bacc / wacc);
        image.data[idx + 3] = Math.floor(aacc / wacc);
      }
    }
  }
  static checkDelta(original, target, delta) {
    for (let rowIx = 0; rowIx < original.height; rowIx++) {
      for (let colIx = 0; colIx < original.width; colIx++) {
        const idx = (rowIx * original.width + colIx) * 4;
        const d = Math.abs(target[idx + 0] - original.data[idx + 0]) + Math.abs(target[idx + 1] - original.data[idx + 1]) + Math.abs(target[idx + 2] - original.data[idx + 2]) + Math.abs(target[idx + 3] - original.data[idx + 3]);
        if (d > delta) {
          target[idx + 0] = original.data[idx];
          target[idx + 1] = original.data[idx + 1];
          target[idx + 2] = original.data[idx + 2];
          target[idx + 3] = original.data[idx + 3];
        }
      }
    }
  }
};
var sharpenKernel = [
  [0, -1, 0],
  [-1, 5, -1],
  [0, -1, 0]
];
function sharpen(imageData, threshold) {
  const applicator = new ConvolutionApplicator(sharpenKernel);
  return applicator.apply(imageData, threshold);
}
var ConvolutionApplicator = class {
  kernel;
  kernelWeight;
  constructor(kernel) {
    this.kernel = kernel;
    this.kernelWeight = kernel.flat().reduce((sum, v) => sum + v, 0);
  }
  apply(imageData, threshold) {
    const res = new Uint8ClampedArray(4 * imageData.width * imageData.height);
    for (let rowIx = 0; rowIx < imageData.height; rowIx++) {
      for (let colIx = 0; colIx < imageData.width; colIx++) {
        this.applyKernelToPixel(imageData, colIx, rowIx, res);
      }
    }
    this.applyThreshold(imageData, res, threshold);
    return {
      width: imageData.width,
      height: imageData.height,
      colorSpace: imageData.colorSpace,
      data: res
    };
  }
  applyKernelToPixel(image, x, y, target) {
    const radius = Math.floor(this.kernel.length / 2);
    const pixelIx = (y * image.width + x) * 4;
    for (let channelIx = 0; channelIx < 4; channelIx++) {
      let channelValue = 0;
      let weight = 0;
      for (let rowOffset = -radius; rowOffset <= radius; rowOffset++) {
        if (y + rowOffset < 0 || y + rowOffset >= image.height) {
          continue;
        }
        for (let colOffset = -radius; colOffset <= radius; colOffset++) {
          if (x + colOffset < 0 || x + colOffset >= image.width) {
            continue;
          }
          const ix = ((y + rowOffset) * image.width + (x + colOffset)) * 4 + channelIx;
          const kernelValue = this.kernel[rowOffset + radius][colOffset + radius];
          channelValue += image.data[ix] * kernelValue;
          weight += kernelValue;
        }
      }
      if (weight !== this.kernelWeight) {
        channelValue *= this.kernelWeight === 0 ? 0 : weight / this.kernelWeight;
      }
      target[pixelIx + channelIx] = channelValue;
    }
  }
  applyThreshold(image, target, threshold) {
    if (threshold <= 0 || threshold === 1 || threshold >= 1024) {
      return;
    }
    threshold = threshold < 1 ? 1024 * threshold : threshold;
    for (let ix = 0; ix < image.data.length; ix += 4) {
      let diff = 0;
      for (let channelIx = ix; channelIx < ix + 4; channelIx++) {
        diff += Math.abs(image.data[channelIx] - target[channelIx]);
      }
      if (diff <= threshold) {
        continue;
      }
      for (let channelIx = ix; channelIx < ix + 4; channelIx++) {
        target[channelIx] = image.data[channelIx];
      }
    }
  }
};
var TraceData;
(function(TraceData2) {
  function toString(td) {
    const output = [];
    for (let colorIx = 0; colorIx < td.areasByColor.length; colorIx++) {
      const areas = td.areasByColor[colorIx];
      if (areas.length === 0) {
        continue;
      }
      output.push(td.colors[colorIx].toString());
      for (const area of areas) {
        const d = area.lineAttributes.map((la) => SvgLineAttributes.toString(la)).join(" ");
        output.push(d);
      }
    }
    return output.join("\n");
  }
  TraceData2.toString = toString;
})(TraceData || (TraceData = {}));
var ImageTracer = class {
  options;
  colorQuantizeFunction;
  constructor(options = null) {
    this.options = Options.buildFrom(options);
    this.colorQuantizeFunction = getColorQuantizeFunction(this.options.colorSamplingMode, this.options.palette);
  }
  /**
   * Set a custom color quantize function.
   */
  setColorQuantizeFunction(fun) {
    this.colorQuantizeFunction = fun;
    return this;
  }
  /**
   * Trace image data and render to SVG
   *
   * @param imageData
   * @returns
   */
  traceImageToSvg(imageData) {
    const drawer = new SvgDrawer(this.options);
    return this.traceImage(imageData, drawer);
  }
  /**
   * Allows to draw traced image with a custom renderer.
   *
   * @param imageData
   * @param drawer
   * @returns
   */
  traceImage(imageData, drawer = null) {
    if (!drawer) {
      drawer = new SvgDrawer(this.options);
    }
    const isVerbose = this.isVerbose();
    isVerbose && console.time(" - Preprocessing time");
    imageData = this.preProcessImage(imageData);
    isVerbose && console.timeEnd(" - Preprocessing time");
    isVerbose && console.time(" - Color indexing time");
    const colorIndex = new ColorIndex(imageData, this.options, this.colorQuantizeFunction);
    isVerbose && console.timeEnd(" - Color indexing time");
    isVerbose && console.time(" - Trace time");
    const traceData = this.imageDataToTraceData(imageData, colorIndex);
    isVerbose && console.timeEnd(" - Trace time");
    isVerbose && console.time(" - Draw time");
    const output = drawer.draw(traceData);
    isVerbose && console.timeEnd(" - Draw time");
    return output;
  }
  isVerbose() {
    return this.options.verbose ?? false;
  }
  preProcessImage(imageData) {
    imageData = ImageToRgba.process(imageData, this.isVerbose());
    if (this.options.blurRadius > 0) {
      imageData = ImageBlurrer.blur(imageData, this.options.blurRadius, this.options.blurDelta);
    }
    if (this.options.sharpen) {
      imageData = sharpen(imageData, this.options.sharpenThreshold);
    }
    return imageData;
  }
  imageDataToTraceData(imageData, colorIndex) {
    if (this.options.layeringMode === LayeringMode.SEQUENTIAL) {
      return this.imageDataToTraceDataWithSequentialLayering(imageData, colorIndex);
    } else {
      return this.imageDataToTraceDataWithParallelLayering(imageData, colorIndex);
    }
  }
  imageDataToTraceDataWithSequentialLayering(imageData, colorIndex) {
    const colorLayers = [];
    const areaScanner = new AreaScanner();
    const pathInterpolator = new PointInterpolator();
    const pathTracer = new PathTracer();
    for (let colorIx = 0; colorIx < colorIndex.palette.length; colorIx++) {
      const edgeRaster = EdgeRasterBuilder.buildForColor(colorIndex, colorIx);
      const areas = areaScanner.scan(edgeRaster, this.options.minShapeOutline);
      const interpolatedPath = pathInterpolator.interpolate(this.options.interpolation, areas, this.options.enhanceRightAngles);
      const outlinedAreas = interpolatedPath.map((path) => pathTracer.trace(path, this.options.lineErrorMargin, this.options.curveErrorMargin));
      colorLayers.push(outlinedAreas);
    }
    return {
      areasByColor: colorLayers,
      colors: colorIndex.palette,
      width: colorIndex.rows[0].length - 2,
      height: colorIndex.rows.length - 2
    };
  }
  imageDataToTraceDataWithParallelLayering(imageData, colorIndex) {
    const edgeRaster = EdgeRasterBuilder.buildForColors(colorIndex);
    if (this.options.layerContainerId) {
      const divRenderer = new DivRenderer();
      divRenderer.drawLayersToDiv(edgeRaster, this.options.scale, this.options.layerContainerId);
    }
    const areaScanner = new AreaScanner();
    const areasByColor = edgeRaster.map((layer) => areaScanner.scan(layer, this.options.minShapeOutline));
    const pathInterpolator = new PointInterpolator();
    const interpolation = this.options.interpolation;
    const enhanceRightAngle = this.options.enhanceRightAngles;
    const interpolatedAreasByColor = areasByColor.map((pathBatch) => pathInterpolator.interpolate(interpolation, pathBatch, enhanceRightAngle));
    const pathTracer = new PathTracer();
    const traceMapper = (path) => pathTracer.trace(path, this.options.lineErrorMargin, this.options.curveErrorMargin);
    const outlinedAreasByColor = interpolatedAreasByColor.map((pathBatch) => pathBatch.map(traceMapper));
    return {
      areasByColor: outlinedAreasByColor,
      colors: colorIndex.palette,
      width: imageData.width,
      height: imageData.height
    };
  }
};
export {
  CreatePaletteMode,
  FillStyle,
  ImageTracer,
  InterpolationMode,
  LayeringMode,
  Options,
  RgbColor,
  RgbColorData,
  SvgDrawer,
  SvgDrawerDefaultOptions,
  TraceData,
  TrimMode
};
//# sourceMappingURL=@image-tracer-ts_core.js.map
