import { ColorDistanceBuffering } from "./ColorIndex";
import { InterpolationMode } from "./PointInterpolator";
import { RgbColorData } from "./RgbColor";
import { SvgDrawerDefaultOptions, SvgDrawerOptions } from "./svg-drawer/SvgDrawerOptions";
export { InterpolationMode, RgbColorData, SvgDrawerOptions, SvgDrawerDefaultOptions };
export interface Options extends BaseOptions, SvgDrawerOptions {
}
export declare enum CreatePaletteMode {
    GENERATE = "generate",
    SAMPLE = "sample",
    SCAN = "scan",
    PALETTE = "palette"
}
export declare enum LayeringMode {
    SEQUENTIAL = 1,
    PARALLEL = 2
}
export interface BaseOptions {
    /**
     * Line tracer error margin.
     * Gives the squared maximum distance a point can be off a trajectory to be
     * still put on a line.
     *
     * Default: 1
     */
    lineErrorMargin: number;
    /**
     * Curve tracer error margin.
     * Gives the squared maximum distance a point can be off a trajectory to be
     * still put on a curve.
     *
     * Default: 1
     */
    curveErrorMargin: number;
    /**
     * Sets interpolation mode.
     */
    interpolation: InterpolationMode;
    /**
     * Do not interpolate right angles.
     *
     * A right angle consists of five points on an outline: the corner point
     * and two adjacent edge points in either direction.
     *
     * Default: true
     */
    enhanceRightAngles: boolean;
    /**
     * Areas on the image with an outline of less than the given number of
     * points will be discarded.
     */
    minShapeOutline: number;
    /**
     * CreatePaletteMode.GENERATE: Generate colors along the spectrum independent of image colors.
     * CreatePaletteMode.SAMPLE: Randomly access image for colors.
     * CreatePaletteMode.SCAN: Step through the image along a raster.
     */
    colorSamplingMode: CreatePaletteMode;
    /**
     * Use custom palette
     */
    palette?: RgbColorData[] | null;
    /**
     * Number of colors in the palette.
     *
     * CreatePaletteMode.GENERATE:
     *  - uses grayscale if less than 8 colors
     *  - otherwise number of points on color cube
     *
     * CreatePaletteMode.SAMPLE:
     *  - number of random samples (can give same color)
     *
     * CreatePaletteMode.SCAN:
     *  - defines step width of scanner
     *  - stop scanning when given number of colors are found
     *
     * Colors will be adjusted during color clustering.
     *
     * Default: 16
     */
    numberOfColors: number;
    /**
     * Number of color clustering cycles.
     */
    colorClusteringCycles: number;
    /**
     * Buffers color distances during clustering.
     *
     * Buffering is very efficient when working with larger palettes sizes
     * (more than 30 colors). On smaller palettes, building the buffer is more
     * expensive than what is saved.
     * The number of distinct colors in the image determines the buffer size
     * and number of skipped calculations.
     *
     * Unless buffering causes issues, the default setting of `reasonable
     * should be fine.
     */
    colorDistanceBuffering: ColorDistanceBuffering;
    /**
     * Threshold for color pruning during color clustering.
     *
     * If ratio between pixels of a color and all pixels is below the given
     * number, the color will be replaced by a random color.
     */
    minColorQuota: number;
    /**
     * Used for old debug output.
     */
    layeringMode: LayeringMode;
    /**
     * Disabled below 1, capped at 5
     */
    blurRadius: number;
    /**
     * Maximum allowed difference between original pixel and blurred pixel when summing up RGBA values.
     * If a blurred pixel exceeds delta, the original pixel is used instead.
     */
    blurDelta: number;
    /**
     * Sharpen pixels
     */
    sharpen: boolean;
    /**
     * Maximum allowed difference between original pixel and sharpened pixel when summing up RGBA values.
     * If a sharpened pixel exceeds threshold, the original pixel is used instead.
     */
    sharpenThreshold: number;
    layerContainerId?: string;
    /**
     * Write status data to console during trace.
     */
    verbose?: boolean;
}
export declare namespace Options {
    /**
     * Create full options object from partial
     */
    function buildFrom(options: Partial<Options> | null): Options;
    const Presets: Readonly<{
        default: Options;
        posterized1: {
            colorSamplingMode: CreatePaletteMode.GENERATE;
            numberOfColors: number;
        };
        posterized2: {
            numberOfColors: number;
            blurRadius: number;
        };
        curvy: {
            lineErrorMargin: number;
            lineFilter: true;
            enhanceRightAngles: false;
        };
        sharp: {
            curveErrorMargin: number;
            lineFilter: false;
        };
        detailed: {
            minShapeOutline: number;
            decimalPlaces: number;
            lineErrorMargin: number;
            curveErrorMargin: number;
            numberOfColors: number;
        };
        smoothed: {
            blurRadius: number;
            blurDelta: number;
        };
        grayscale: {
            colorSamplingMode: CreatePaletteMode.GENERATE;
            colorClusteringCycles: number;
            numberOfColors: number;
        };
        fixedpalette: {
            colorSamplingMode: CreatePaletteMode.GENERATE;
            colorClusteringCycles: number;
            numberOfColors: number;
        };
        randomsampling1: {
            colorSamplingMode: CreatePaletteMode.SAMPLE;
            numberOfColors: number;
        };
        randomsampling2: {
            colorSamplingMode: CreatePaletteMode.SAMPLE;
            numberOfColors: number;
        };
        artistic1: {
            colorSamplingMode: CreatePaletteMode.GENERATE;
            colorClusteringCycles: number;
            minShapeOutline: number;
            blurRadius: number;
            blurDelta: number;
            lineErrorMargin: number;
            lineFilter: true;
            numberOfColors: number;
            strokeWidth: number;
        };
        artistic2: {
            curveErrorMargin: number;
            colorSamplingMode: CreatePaletteMode.GENERATE;
            colorClusteringCycles: number;
            numberOfColors: number;
            strokeWidth: number;
        };
        artistic3: {
            curveErrorMargin: number;
            lineErrorMargin: number;
            numberOfColors: number;
        };
        artistic4: {
            curveErrorMargin: number;
            lineErrorMargin: number;
            numberOfColors: number;
            blurRadius: number;
            blurDelta: number;
            strokeWidth: number;
        };
        posterized3: {
            lineErrorMargin: number;
            curveErrorMargin: number;
            minShapeOutline: number;
            enhanceRightAngles: true;
            colorSamplingMode: CreatePaletteMode.GENERATE;
            numberOfColors: number;
            minColorQuota: number;
            colorClusteringCycles: number;
            blurRadius: number;
            blurDelta: number;
            strokeWidth: number;
            lineFilter: false;
            decimalPlaces: number;
            palette: {
                r: number;
                g: number;
                b: number;
                a: number;
            }[];
        };
    }>;
}
//# sourceMappingURL=Options.d.ts.map