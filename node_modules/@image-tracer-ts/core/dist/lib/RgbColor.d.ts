export type RgbColorData = {
    r: number;
    g: number;
    b: number;
    a?: number;
};
export declare namespace RgbColorData {
    function toString(c: RgbColorData): string;
}
export type RgbColorCounter = RgbColorData & {
    a: number;
    n: number;
};
export type ColorCounts = RgbColorCounter[];
export declare class RgbColor implements RgbColorData {
    r: number;
    g: number;
    b: number;
    a: number;
    /**
     * If the `a` value is below this value, a color is considered invisible.
     */
    static readonly MINIMUM_A = 13;
    constructor(r?: number, g?: number, b?: number, a?: number);
    static fromRgbColorData(c: RgbColorData): RgbColor;
    static createRandomColor(): RgbColor;
    static fromPixelArray(pixelData: ArrayLike<number>, pixelIndex: number, isRgba?: boolean): RgbColor;
    static fromHex(hex: string): RgbColor;
    static buildColorAverage(counter: RgbColorCounter): RgbColor;
    isInvisible(): boolean;
    hasOpacity(): boolean;
    setFromColorCounts(counter: RgbColorCounter): void;
    randomize(): void;
    setFromPixelArray(pixelData: ArrayLike<number>, pixelIndex: number, isRgba?: boolean): void;
    get [Symbol.toStringTag](): string;
    calculateDistanceToPixelInArray(pixelData: ArrayLike<number>, pixelIndex: number, isRgba?: boolean): number;
    equals(color: RgbColorData): boolean;
    toCssColor(): string;
    toCssColorHex(): `#${number}`;
    toInt32(): number;
}
//# sourceMappingURL=RgbColor.d.ts.map